#Rapport projekt Webbteknik 2

##Inledning
I mitt projekt har jag valt att göra en väderapplikation i form av en Single page application, med funktionalitet att kunna söka på valfri stad och då få en väderleksrapport för de fem närmaste dagarna, tillsammans med en karta från Google Maps API, som visar var användarens valda stad finns. Till detta kan användaren även logga in sig med ett Google-konto, för att kunna få extra funktionalitet i form av en favorit-lista där man kan spara sina städer som man ofta vill se vädret för. Applikationen cachar själv de resultat som användarna söker på, vilket är en förutsättning för att kunna använda api:er som YR.no. Det finns liknande applikationer redan, men detta var för mig främst ett sätt att utforska tekniken bakom en sådan site. Applikationen är väldigt lik den applikation vi skapade i ASP.NET MVC-kursen, men med den stora skillnaden att den nu är skriven i PHP. 

##Schematisk bild över aktiektur
Finnes här: https://github.com/hg222dt/1DV449_Projekt/blob/master/Schematisk%20bild%20arkitektur.pdf

##Klientsida
Applikationen är en Single page application som gör vädersökningar från klienten genom att anropa sin server via ajax-förfrågningar. Detta förhöjer användarupplevelsen och skapar ett mycket mer sammanhängande flöde än om web-sidan helt och hållet skulle laddas om vid varje sökning. Eftersom att det fungerar på detta viset, måste även medföljande script dynamiskt skapa och rendera ut nya väderleksrapporter eftersökningar.
För inloggade användare går det ju även att spara favoriter från klienten. Dessa favoriter, och tillhörande väderdata, sparas sedan i localstorage, om detta finns stöd för i webbläsaren. Datan som sparats i localstorage används senare till om man som användare tappar kontakten med internet (mer om det i offline first-stycket).
På klientsidan cacheas även en hel del resurser. Detta på grund av att klienten snabbare ska kunna ladda sidan i framtiden. Exempelvis sparas alla väderbilder i appCache, men även de sn hel del script och andra resurser. En offline-sida caches ut ifall att användaren skulle tappa kontakt med internet.
Det ska förtydligas att varje sökresultat även visar en kartbild på vald stad, på en karta från Google Maps API, som är kopplad till applikationen.

##Serversida
Applikationen på serversidan är byggd med hjälp utav PHP, och databasen sqlite3. Den har en MVC-arkitektur som gör den flexibel och skalbar. Alla anrop för att hämta väder kommer i nuläget in till applikationen från klienten, i form av ajax-anrop. 
Ett anrop för en viss stad fungerar som så att servern först hämtar data från Geonames API för att hämta rätt stadsdata för ett visst sökord, vilket användaren angivit. Om det visar sig att flera städer matchat söktermen, returneras dessa olika städers data till klienten, för att användaren där ska kunna välja en av dessa funna städer. När en av dessa städer har valts görs då ett nytt ajax-anrop till servern. Härifrån anropas en metod som även skulle anropats om bara en stad hittats på söktermen i den första omgången. Det är nu servern ska returnera väder för den specifikt valda staden.
Servern behöver först kontrollera om denna stad finns cachad i databasen redan. Om så är fallet, kontrolleras om stadens cacheningstid på servern har gått ut eller inte. Om den inte har gått ut, hämtas stadens väderleksrapport från servern, och returneras till klienten i jsonformat. Om cacheningstiden däremot har gått ut, måste servern istället hämta ny väderdata från yr.no:s API.
Detta görs med hjälp av den stadsdata som servern har att tillhandahålla med.
När data har hämtats från yr.no:s API, placeras de olika väderdagarna in i olika objekt, vilka sedan tillsammans placeras i en väderleksrapportsobjekt, vid sidan om ett stadsobjekt som innehåller all för klienten, nödvändig information om staden.
Detta objekt returneras tillbaka i json-format till klienten.

##Felhantering
Om användaren exempelvis matar in en sökterm som inte kan hittas i form av en stad, kommer Geonames inte att kunna returnera ett relevant resultat. Då fångas detta upp i kontrollern, och istället skickas en json-sträng tillbaka till klienten som talar om att inget resultat har hittats. 
Detsamma gäller om yr.no:s API inte hittar väder för just den staden användaren har sökt på. Då kommer en json-sträng tala om för klienten att sökningen inte hittade någon matchning.
På klienten kommer sedan grafik att skapas för att berätta för användaren att inget resultat kunde hittas. 

##OAuth
Min webbapp använder sig av Google OAuth för att göra inloggningar, något ni bland annat tar upp i självstudierna för vecka 3. Detta görs med hjälp av “Google APIs Client Library for PHP”, som ger utvecklare mycket färdigt, att lägga ovanpå appen, tillsammans med beprövad säkerhet. 
Jag valde Google som inloggningstjänst. Detta eftersom att det verkade finnas bra bibliotek och hjälp för detta till php, samt att väldigt många har ett Google-konto de kan logga in med hjälp utav.
När det kommer till funktionalitet, valde jag att använda mig av det Google-id man får tillbaka från google, efter en lyckad OAuth-inloggning, för att kunna särskilja användare åt. Jag sparar därför detta id, tillsammans med användarens e-post på databasen för att på så vis kunna spara användarspecifik data, i form av favoritstäder, åt användaren.
Jag kommer återkomma till offline-funktionalitet senare, men det kan vara värt att nämna här att användarspecifik favorit-data även kommer att visas när användaren går offline (om användaren var inloggad innan han eller hon gick offline). Därför finns det en “Logga ut”-knapp i offline läge som gör att användarens data raderas från localstorage, och inte kommer att visas i offlineläge. När användaren sedan får internet igen kommer denne inte att vara inloggad på sin sida heller. Däremot fungerar ju OAuth som så att om användaren inte har gjort revoke via som console på Googles inställningssida för just vår app, så kommer det gå att logga in genom ett knapptryck igen, till vår app. Men det är så googles api fungerar och inte så jättemycket att göra åt. Tanken med en logga ut-knapp i offlineläget är främst att användardata inte ska behöva visas på sidan om användaren inte vill det.

##Säkerhet
Som tidigare nämnt har jag jobbat med “Google APIs Client Library for PHP”, för åstadkomma inloggning mot Google med OAuth, ett val jag delvis gjorde på grund av säkerhetshänseende. Jag hade först funderingar på att göra detta enbart från klienten, men insåg att detta skulle bli för osäkert när klienten sedan skulle kommunicera med servern med identifieringar, som illasinnade användare skulle kunna dra fördel av genom troligtvis kunna injicera data till servern och logga in på andra användares konton. Därför kändes Googles klientinloggning som en säker lösning att arbeta med, just eftersom att jag skulle koppla varje användare till ett eget lokalt konto på min databsa. 
Det är även viktigt att skydda databasen mot illasinnade användare som får för sig att injicera SQL-kod som söktermer. Därför görs varje gång en “prepare” innan varje databas-anrop, som hjälper mot detta scenario.
Ur säkerhetssynpunkt är det även viktigt att tänka på den localstorage vi jobbar med. Eftersom att jag inte använder mig av någon kryptering där, innebär en utloggning för användaren alltid att favoritdata raderas från local storage. Detta för att det annars är möjligt att få ut denna data från annat håll på användarens enhet, även om användaren inte är inloggad på vår webbapp.
Tills sist så har jag implementerat en kontroll mot csrf-attacker, genom att generera ett csrf-token i form av base64-sträng som jag gömmer i ett gömt input-fält på sidan. Härifrån hämtar mitt script på klienten sedan detta csrf-token för att skicka med varje ajax-anrop till servern.
På servern kontrolleras sedan att inkommande csrf-token överensstämmer med det token som finns sparat i sessionen, sedan innan. Om dessa överensstämmer släpps anropet igenom. Detta pratade bland annat Johan om i sin video om säkerhet under självstudierna vecka 3.

##Prestanda
Cacheningen som görs med hjälp av vår databas backend har givetvis en del att göra med de vilkor som de externa API:erna ställer på sina användare, dvs att man inte får göra likadana anrop till dem i följd. Men denna cachning har även en annan fördel - att väderdata hämtas snabbare från servern, vilket är en klart optimerande förbättring för applikationen.
Även på klientsidan kan vi givetvis se fördelar med cachening. Här används till viss del cachening i form av appCache för att ladda ner de resurser som behöver cacheas. Det handlar om främst om bilder men även en del stora script som cacheas, och återanvänds.
Slutligen är även AJAX-anropen en prestandahöjande faktor, med tanke på att webbappen, innefattar en karta från Google Maps API. Om denna karat helt och hållet ska laddas om vid varje anrop skulle appen helt enkelt sluka en hel del mer data, vilket betyder längre väntetider för användaren. 

##Offline-first 
Applikationen är byggd för att kunna serva användare, även i fallen då internet inte fungerar som det ska. Som användare får man ofta en ful fel-sida upptryckt i ansiktet när klienten tappat kontakt med internet. Detta problem har vi avhjälpt genom att använda oss av appCache och spara ner en offline-sida som användaren kommer att dirigeras till utifrån fallet att klienten tappat kontakten med internet. Om användaren inte var inloggad via OAuth innan klienten tappade kontakten med internet, går det inte att utföra något i offline-läge. Dock får man ett trevligt meddelande om att klienten inte verkar komma åt internet. Fallet är dock annorlunda om man som användare däremot var inloggad innan klienten förlorade kontakt med internet, och dessutom hade sparat några favoriter. I offline-läge kan användaren då titta på sina favoritstäders väderleksrapporter, i det tillstånd de var i, sist man uppdaterade dem. Detta åstdakomms genom att all favorit-väderdata alltid sparas i localstorage som en json-sträng, om localstorage stöds av webbläsaren. När webbläsaren öppnar offline-versionen av webbsidan, hämtar den då även data för de favoriter som användaren sparat ner.
Ur användarhänseende tror jag detta är väldigt bra, utifrån att en användare inte söker på så extremt många städer, utan har sina favoriter/favorit som den vill veta vädret för. När man som användare då råkar vara offline, vill man kanske ändå se senaste uppdateringen som gjorts på vädret, utan att mötas av en intetsägande felsida. Dock ska det tilläggas att vi tydligt promptar användaren om att klienten är i offline-läge. Utifrån detta gör man användaren varse om att det kanske inte är den senaste datan som hämtats för vädret som visas just då.

##Risker
För det första ska sägas att jag inte har någon typ av SSL-certifikat, vilket gör att jag inte kan köra min applikation över https. Detta är inte att rekommendera när man kör OAuth, vilket innebär att datan som delas mellan dig och google körs på “öppen lina” och enkelt skulle kunna snappas upp av illasinnade individer. Det är därför att rekommendera att min applikation inte körs används i skarpt läge förrän den har ett giltigt SSL-certifikat. För att hänvisa till teori här, tar Johan bland annat upp detta en del i sin föreläsning om säkerhet, i självstudierna under vecka 3.
I övrigt kan väl även tilläggas att det finns en risk (om än liten) att webbsiten skulle kunna bli överbelastad, då jag exempelvis endast använder mig av en sqlite databas. Jag använder mig inte heller av någon form av lastbalanserar för att kunna ta stora mängder anrop, vilket i ett sådant scenario skulle vara nödvändigt. Dock får vi nog lägga in en brasklapp om att detta scenario i vårt fall kan ta lite tid att uppnå.

##Reflektion
Detta projekt har varit intressant att genomföra. För min del känner jag att mina resultat blir bättre och bättre för varje projekt, vilket alltid är skönt att känna. Jag skulle dock velat haft mer tid för testning av applikationen, något men i och för sig känner efter varje projekt. Det säger väl i och för sig en del om att man kanske ska börja omprioritera tiden man lägger ner på utvecklingen, genom att lägga ner mer tid mer frekvent på testning. Kanske rentav börja utveckla mer testdrivet. 
Vad som tog mest tid och energi från mig var just att inte arbeta mer någon ORM för databasen. Det var väldigt enerverande att försöka bygga alla databsanrop utan att få någon bra feedback på vad som inte fungerade, när ingenting hände efter mina anrop.
Vad jag gärna också hunnit med skulle ha varit att implementera funktionalitet för geolocation, så att en väderleksrapport kan hämtas bara beroende på var man befinner sig, samt att kartan simultant följer med i detta och visar var man befinner sig.
Jag hade också önskat att jag kunnat ha mer tid till en responsiv design. Just i samband med geolocation skulle en mobilversion av webbappen göra sig perfekt. 
